
sacumi_melanjor_ATtiny2313.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002e2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002e  00800060  000002e2  00000376  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000d  0080008e  0080008e  000003a4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000003a4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000003d4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000048  00000000  00000000  00000414  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000752  00000000  00000000  0000045c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000577  00000000  00000000  00000bae  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000037e  00000000  00000000  00001125  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000b4  00000000  00000000  000014a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004a3  00000000  00000000  00001558  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000001a8  00000000  00000000  000019fb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000038  00000000  00000000  00001ba3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	14 c0       	rjmp	.+40     	; 0x2a <__ctors_end>
   2:	2c c0       	rjmp	.+88     	; 0x5c <__bad_interrupt>
   4:	2b c0       	rjmp	.+86     	; 0x5c <__bad_interrupt>
   6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
   8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
   a:	28 c0       	rjmp	.+80     	; 0x5c <__bad_interrupt>
   c:	27 c0       	rjmp	.+78     	; 0x5c <__bad_interrupt>
   e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
  10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
  12:	24 c0       	rjmp	.+72     	; 0x5c <__bad_interrupt>
  14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
  16:	22 c0       	rjmp	.+68     	; 0x5c <__bad_interrupt>
  18:	21 c0       	rjmp	.+66     	; 0x5c <__bad_interrupt>
  1a:	48 c0       	rjmp	.+144    	; 0xac <__vector_13>
  1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
  1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
  20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
  22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
  24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>
  26:	1a c0       	rjmp	.+52     	; 0x5c <__bad_interrupt>
  28:	19 c0       	rjmp	.+50     	; 0x5c <__bad_interrupt>

0000002a <__ctors_end>:
  2a:	11 24       	eor	r1, r1
  2c:	1f be       	out	0x3f, r1	; 63
  2e:	cf ed       	ldi	r28, 0xDF	; 223
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	10 e0       	ldi	r17, 0x00	; 0
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e2 ee       	ldi	r30, 0xE2	; 226
  3a:	f2 e0       	ldi	r31, 0x02	; 2
  3c:	02 c0       	rjmp	.+4      	; 0x42 <__SREG__+0x3>
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0
  42:	ae 38       	cpi	r26, 0x8E	; 142
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <__SP_L__+0x1>

00000048 <__do_clear_bss>:
  48:	20 e0       	ldi	r18, 0x00	; 0
  4a:	ae e8       	ldi	r26, 0x8E	; 142
  4c:	b0 e0       	ldi	r27, 0x00	; 0
  4e:	01 c0       	rjmp	.+2      	; 0x52 <.do_clear_bss_start>

00000050 <.do_clear_bss_loop>:
  50:	1d 92       	st	X+, r1

00000052 <.do_clear_bss_start>:
  52:	ab 39       	cpi	r26, 0x9B	; 155
  54:	b2 07       	cpc	r27, r18
  56:	e1 f7       	brne	.-8      	; 0x50 <.do_clear_bss_loop>
  58:	fa d0       	rcall	.+500    	; 0x24e <main>
  5a:	41 c1       	rjmp	.+642    	; 0x2de <_exit>

0000005c <__bad_interrupt>:
  5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <button_on_off_callback>:
	}
}

void button_on_off_callback()
{
	board_led_status = !board_led_status;
  5e:	90 91 9a 00 	lds	r25, 0x009A	; 0x80009a <board_led_status>
  62:	81 e0       	ldi	r24, 0x01	; 1
  64:	89 27       	eor	r24, r25
  66:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <board_led_status>
	if (board_led_status) PORTD |= 1 << pin_board_led;
  6a:	88 23       	and	r24, r24
  6c:	21 f0       	breq	.+8      	; 0x76 <button_on_off_callback+0x18>
  6e:	82 b3       	in	r24, 0x12	; 18
  70:	81 60       	ori	r24, 0x01	; 1
  72:	82 bb       	out	0x12, r24	; 18
  74:	08 95       	ret
	else PORTD &= ~(1 << pin_board_led);
  76:	82 b3       	in	r24, 0x12	; 18
  78:	8e 7f       	andi	r24, 0xFE	; 254
  7a:	82 bb       	out	0x12, r24	; 18
  7c:	08 95       	ret

0000007e <init_port>:
}

void init_port()
{
	// board led pin
	DDRD = 1 << pin_board_led;
  7e:	81 e0       	ldi	r24, 0x01	; 1
  80:	81 bb       	out	0x11, r24	; 17
	PORTD = 1 << pin_board_led;
  82:	82 bb       	out	0x12, r24	; 18
	board_led_status = true;
  84:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <board_led_status>
	
	// buttons
	// on/off button
	DDRB = 0;
  88:	17 ba       	out	0x17, r1	; 23
	PORTB = 1 << pin_button_on_off;
  8a:	92 e0       	ldi	r25, 0x02	; 2
  8c:	98 bb       	out	0x18, r25	; 24
	// reset button
	PORTB = 1 << pin_button_reset;
  8e:	88 bb       	out	0x18, r24	; 24
	// red button
	PORTD |= 1 << pin_button_red;
  90:	82 b3       	in	r24, 0x12	; 18
  92:	80 64       	ori	r24, 0x40	; 64
  94:	82 bb       	out	0x12, r24	; 18
  96:	08 95       	ret

00000098 <init_timers>:
}

void init_timers()
{
	TCCR0A = 1 << WGM01; // compare mode
  98:	82 e0       	ldi	r24, 0x02	; 2
  9a:	80 bf       	out	0x30, r24	; 48
	TCCR0B = 1 << CS01 | 1 << CS00; // 64 prescaler
  9c:	83 e0       	ldi	r24, 0x03	; 3
  9e:	83 bf       	out	0x33, r24	; 51
	OCR0A = 62; // 1 ms period
  a0:	8e e3       	ldi	r24, 0x3E	; 62
  a2:	86 bf       	out	0x36, r24	; 54
	TIMSK = 1 << OCIE0A; // timer compare interrupt enable
  a4:	81 e0       	ldi	r24, 0x01	; 1
  a6:	89 bf       	out	0x39, r24	; 57
	TIFR = 1 << OCF0A;
  a8:	88 bf       	out	0x38, r24	; 56
  aa:	08 95       	ret

000000ac <__vector_13>:
}

ISR(TIMER0_COMPA_vect)
{
  ac:	1f 92       	push	r1
  ae:	0f 92       	push	r0
  b0:	0f b6       	in	r0, 0x3f	; 63
  b2:	0f 92       	push	r0
  b4:	11 24       	eor	r1, r1
  b6:	8f 93       	push	r24
  b8:	9f 93       	push	r25
  ba:	af 93       	push	r26
  bc:	bf 93       	push	r27
	time_ms++;
  be:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <time_ms>
  c2:	90 91 97 00 	lds	r25, 0x0097	; 0x800097 <time_ms+0x1>
  c6:	a0 91 98 00 	lds	r26, 0x0098	; 0x800098 <time_ms+0x2>
  ca:	b0 91 99 00 	lds	r27, 0x0099	; 0x800099 <time_ms+0x3>
  ce:	01 96       	adiw	r24, 0x01	; 1
  d0:	a1 1d       	adc	r26, r1
  d2:	b1 1d       	adc	r27, r1
  d4:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <time_ms>
  d8:	90 93 97 00 	sts	0x0097, r25	; 0x800097 <time_ms+0x1>
  dc:	a0 93 98 00 	sts	0x0098, r26	; 0x800098 <time_ms+0x2>
  e0:	b0 93 99 00 	sts	0x0099, r27	; 0x800099 <time_ms+0x3>
}
  e4:	bf 91       	pop	r27
  e6:	af 91       	pop	r26
  e8:	9f 91       	pop	r25
  ea:	8f 91       	pop	r24
  ec:	0f 90       	pop	r0
  ee:	0f be       	out	0x3f, r0	; 63
  f0:	0f 90       	pop	r0
  f2:	1f 90       	pop	r1
  f4:	18 95       	reti

000000f6 <button_tick>:

// process button
void button_tick(struct buttons *button)
{
  f6:	cf 92       	push	r12
  f8:	df 92       	push	r13
  fa:	ef 92       	push	r14
  fc:	ff 92       	push	r15
  fe:	cf 93       	push	r28
 100:	df 93       	push	r29
 102:	ec 01       	movw	r28, r24
	bool pin_level = ((1 << button->pin) & *button->port);
 104:	81 e0       	ldi	r24, 0x01	; 1
 106:	90 e0       	ldi	r25, 0x00	; 0
 108:	08 80       	ld	r0, Y
 10a:	02 c0       	rjmp	.+4      	; 0x110 <button_tick+0x1a>
 10c:	88 0f       	add	r24, r24
 10e:	99 1f       	adc	r25, r25
 110:	0a 94       	dec	r0
 112:	e2 f7       	brpl	.-8      	; 0x10c <button_tick+0x16>
 114:	e9 81       	ldd	r30, Y+1	; 0x01
 116:	fa 81       	ldd	r31, Y+2	; 0x02
 118:	20 81       	ld	r18, Z
 11a:	30 e0       	ldi	r19, 0x00	; 0
 11c:	28 23       	and	r18, r24
 11e:	39 23       	and	r19, r25
	uint32_t past_time;
	
	if (button->stage != passive)
 120:	88 85       	ldd	r24, Y+8	; 0x08
 122:	88 23       	and	r24, r24
 124:	81 f0       	breq	.+32     	; 0x146 <button_tick+0x50>
	{
		past_time = time_ms - button->time_counter; 
 126:	40 91 96 00 	lds	r20, 0x0096	; 0x800096 <time_ms>
 12a:	50 91 97 00 	lds	r21, 0x0097	; 0x800097 <time_ms+0x1>
 12e:	60 91 98 00 	lds	r22, 0x0098	; 0x800098 <time_ms+0x2>
 132:	70 91 99 00 	lds	r23, 0x0099	; 0x800099 <time_ms+0x3>
 136:	cc 80       	ldd	r12, Y+4	; 0x04
 138:	dd 80       	ldd	r13, Y+5	; 0x05
 13a:	ee 80       	ldd	r14, Y+6	; 0x06
 13c:	ff 80       	ldd	r15, Y+7	; 0x07
 13e:	4c 19       	sub	r20, r12
 140:	5d 09       	sbc	r21, r13
 142:	6e 09       	sbc	r22, r14
 144:	7f 09       	sbc	r23, r15
	}
	
	switch (button->stage)
 146:	82 30       	cpi	r24, 0x02	; 2
 148:	49 f1       	breq	.+82     	; 0x19c <button_tick+0xa6>
 14a:	28 f4       	brcc	.+10     	; 0x156 <button_tick+0x60>
 14c:	88 23       	and	r24, r24
 14e:	59 f0       	breq	.+22     	; 0x166 <button_tick+0x70>
 150:	81 30       	cpi	r24, 0x01	; 1
 152:	d9 f0       	breq	.+54     	; 0x18a <button_tick+0x94>
 154:	75 c0       	rjmp	.+234    	; 0x240 <button_tick+0x14a>
 156:	84 30       	cpi	r24, 0x04	; 4
 158:	09 f4       	brne	.+2      	; 0x15c <button_tick+0x66>
 15a:	5b c0       	rjmp	.+182    	; 0x212 <button_tick+0x11c>
 15c:	88 f1       	brcs	.+98     	; 0x1c0 <button_tick+0xca>
 15e:	85 30       	cpi	r24, 0x05	; 5
 160:	09 f4       	brne	.+2      	; 0x164 <button_tick+0x6e>
 162:	68 c0       	rjmp	.+208    	; 0x234 <button_tick+0x13e>
 164:	6d c0       	rjmp	.+218    	; 0x240 <button_tick+0x14a>
	{
		case passive:
			if (pin_level == false) 
 166:	23 2b       	or	r18, r19
 168:	09 f0       	breq	.+2      	; 0x16c <button_tick+0x76>
 16a:	6a c0       	rjmp	.+212    	; 0x240 <button_tick+0x14a>
			{
				button->stage = debounce_press;
 16c:	81 e0       	ldi	r24, 0x01	; 1
 16e:	88 87       	std	Y+8, r24	; 0x08
				button->time_counter = time_ms;
 170:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <time_ms>
 174:	90 91 97 00 	lds	r25, 0x0097	; 0x800097 <time_ms+0x1>
 178:	a0 91 98 00 	lds	r26, 0x0098	; 0x800098 <time_ms+0x2>
 17c:	b0 91 99 00 	lds	r27, 0x0099	; 0x800099 <time_ms+0x3>
 180:	8c 83       	std	Y+4, r24	; 0x04
 182:	9d 83       	std	Y+5, r25	; 0x05
 184:	ae 83       	std	Y+6, r26	; 0x06
 186:	bf 83       	std	Y+7, r27	; 0x07
 188:	5b c0       	rjmp	.+182    	; 0x240 <button_tick+0x14a>
			}
		break;
		
		case debounce_press:
			if (past_time >= buttons_debounce_time) 
 18a:	4a 30       	cpi	r20, 0x0A	; 10
 18c:	51 05       	cpc	r21, r1
 18e:	61 05       	cpc	r22, r1
 190:	71 05       	cpc	r23, r1
 192:	08 f4       	brcc	.+2      	; 0x196 <button_tick+0xa0>
 194:	55 c0       	rjmp	.+170    	; 0x240 <button_tick+0x14a>
			{
				button->stage = interference;
 196:	82 e0       	ldi	r24, 0x02	; 2
 198:	88 87       	std	Y+8, r24	; 0x08
 19a:	52 c0       	rjmp	.+164    	; 0x240 <button_tick+0x14a>
			}
		break;
		
		case interference:
			if (pin_level == true) // if we catch interference
 19c:	23 2b       	or	r18, r19
 19e:	09 f0       	breq	.+2      	; 0x1a2 <button_tick+0xac>
			{
				button->stage = passive; // stop proccess button
 1a0:	18 86       	std	Y+8, r1	; 0x08
			}
			
			if (past_time >= (buttons_interference_time + buttons_debounce_time))
 1a2:	4e 36       	cpi	r20, 0x6E	; 110
 1a4:	51 05       	cpc	r21, r1
 1a6:	61 05       	cpc	r22, r1
 1a8:	71 05       	cpc	r23, r1
 1aa:	08 f4       	brcc	.+2      	; 0x1ae <button_tick+0xb8>
 1ac:	49 c0       	rjmp	.+146    	; 0x240 <button_tick+0x14a>
			{
				button->stage = waiting_release;
 1ae:	83 e0       	ldi	r24, 0x03	; 3
 1b0:	88 87       	std	Y+8, r24	; 0x08
				
				if (button->type == single_click_press) button->button_callback();
 1b2:	8b 81       	ldd	r24, Y+3	; 0x03
 1b4:	81 11       	cpse	r24, r1
 1b6:	44 c0       	rjmp	.+136    	; 0x240 <button_tick+0x14a>
 1b8:	ed 85       	ldd	r30, Y+13	; 0x0d
 1ba:	fe 85       	ldd	r31, Y+14	; 0x0e
 1bc:	09 95       	icall
 1be:	40 c0       	rjmp	.+128    	; 0x240 <button_tick+0x14a>
			}
		break;
		
		case waiting_release:
			if (pin_level == true)
 1c0:	23 2b       	or	r18, r19
 1c2:	a9 f0       	breq	.+42     	; 0x1ee <button_tick+0xf8>
			{
				if (button->type == long_click) button->button_callback(); // if button was released before long click called
 1c4:	8b 81       	ldd	r24, Y+3	; 0x03
 1c6:	82 30       	cpi	r24, 0x02	; 2
 1c8:	19 f4       	brne	.+6      	; 0x1d0 <button_tick+0xda>
 1ca:	ed 85       	ldd	r30, Y+13	; 0x0d
 1cc:	fe 85       	ldd	r31, Y+14	; 0x0e
 1ce:	09 95       	icall
				
				button->stage = debounce_release;
 1d0:	85 e0       	ldi	r24, 0x05	; 5
 1d2:	88 87       	std	Y+8, r24	; 0x08
				button->time_counter = time_ms;
 1d4:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <time_ms>
 1d8:	90 91 97 00 	lds	r25, 0x0097	; 0x800097 <time_ms+0x1>
 1dc:	a0 91 98 00 	lds	r26, 0x0098	; 0x800098 <time_ms+0x2>
 1e0:	b0 91 99 00 	lds	r27, 0x0099	; 0x800099 <time_ms+0x3>
 1e4:	8c 83       	std	Y+4, r24	; 0x04
 1e6:	9d 83       	std	Y+5, r25	; 0x05
 1e8:	ae 83       	std	Y+6, r26	; 0x06
 1ea:	bf 83       	std	Y+7, r27	; 0x07
 1ec:	29 c0       	rjmp	.+82     	; 0x240 <button_tick+0x14a>
			} else if (button->type == long_click) {
 1ee:	8b 81       	ldd	r24, Y+3	; 0x03
 1f0:	82 30       	cpi	r24, 0x02	; 2
 1f2:	31 f5       	brne	.+76     	; 0x240 <button_tick+0x14a>
				if (past_time >= button->time_for_long_click) // if time for long click became
 1f4:	89 85       	ldd	r24, Y+9	; 0x09
 1f6:	9a 85       	ldd	r25, Y+10	; 0x0a
 1f8:	ab 85       	ldd	r26, Y+11	; 0x0b
 1fa:	bc 85       	ldd	r27, Y+12	; 0x0c
 1fc:	48 17       	cp	r20, r24
 1fe:	59 07       	cpc	r21, r25
 200:	6a 07       	cpc	r22, r26
 202:	7b 07       	cpc	r23, r27
 204:	e8 f0       	brcs	.+58     	; 0x240 <button_tick+0x14a>
				{
					button->stage = waiting_release_longclick;
 206:	84 e0       	ldi	r24, 0x04	; 4
 208:	88 87       	std	Y+8, r24	; 0x08
					button->button_callback();
 20a:	ed 85       	ldd	r30, Y+13	; 0x0d
 20c:	fe 85       	ldd	r31, Y+14	; 0x0e
 20e:	09 95       	icall
 210:	17 c0       	rjmp	.+46     	; 0x240 <button_tick+0x14a>
				}
			}
		break;
		
		case waiting_release_longclick:
			if (pin_level == true)
 212:	23 2b       	or	r18, r19
 214:	a9 f0       	breq	.+42     	; 0x240 <button_tick+0x14a>
			{	
				button->stage = debounce_release;
 216:	85 e0       	ldi	r24, 0x05	; 5
 218:	88 87       	std	Y+8, r24	; 0x08
				button->time_counter = time_ms;
 21a:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <time_ms>
 21e:	90 91 97 00 	lds	r25, 0x0097	; 0x800097 <time_ms+0x1>
 222:	a0 91 98 00 	lds	r26, 0x0098	; 0x800098 <time_ms+0x2>
 226:	b0 91 99 00 	lds	r27, 0x0099	; 0x800099 <time_ms+0x3>
 22a:	8c 83       	std	Y+4, r24	; 0x04
 22c:	9d 83       	std	Y+5, r25	; 0x05
 22e:	ae 83       	std	Y+6, r26	; 0x06
 230:	bf 83       	std	Y+7, r27	; 0x07
 232:	06 c0       	rjmp	.+12     	; 0x240 <button_tick+0x14a>
			}
		break;
		
		case debounce_release:
			if (past_time >= buttons_debounce_time)
 234:	4a 30       	cpi	r20, 0x0A	; 10
 236:	51 05       	cpc	r21, r1
 238:	61 05       	cpc	r22, r1
 23a:	71 05       	cpc	r23, r1
 23c:	08 f0       	brcs	.+2      	; 0x240 <button_tick+0x14a>
			{
				button->stage = passive;
 23e:	18 86       	std	Y+8, r1	; 0x08
			}
		break;
	}
}
 240:	df 91       	pop	r29
 242:	cf 91       	pop	r28
 244:	ff 90       	pop	r15
 246:	ef 90       	pop	r14
 248:	df 90       	pop	r13
 24a:	cf 90       	pop	r12
 24c:	08 95       	ret

0000024e <main>:
#include <avr/interrupt.h>
#include "sacumi_melanjor_ATtiny2313.h"

int main(void)
{
	init_port();
 24e:	17 df       	rcall	.-466    	; 0x7e <init_port>
	init_timers();
 250:	23 df       	rcall	.-442    	; 0x98 <init_timers>
	sei();
 252:	78 94       	sei
	
    while (1) 
    {
		if (time_counter_board_led_blink < time_ms)
 254:	40 91 92 00 	lds	r20, 0x0092	; 0x800092 <time_counter_board_led_blink>
 258:	50 91 93 00 	lds	r21, 0x0093	; 0x800093 <time_counter_board_led_blink+0x1>
 25c:	60 91 94 00 	lds	r22, 0x0094	; 0x800094 <time_counter_board_led_blink+0x2>
 260:	70 91 95 00 	lds	r23, 0x0095	; 0x800095 <time_counter_board_led_blink+0x3>
 264:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <time_ms>
 268:	90 91 97 00 	lds	r25, 0x0097	; 0x800097 <time_ms+0x1>
 26c:	a0 91 98 00 	lds	r26, 0x0098	; 0x800098 <time_ms+0x2>
 270:	b0 91 99 00 	lds	r27, 0x0099	; 0x800099 <time_ms+0x3>
 274:	48 17       	cp	r20, r24
 276:	59 07       	cpc	r21, r25
 278:	6a 07       	cpc	r22, r26
 27a:	7b 07       	cpc	r23, r27
 27c:	70 f4       	brcc	.+28     	; 0x29a <main+0x4c>
		{
			time_counter_board_led_blink = time_ms + 1000;
 27e:	ac 01       	movw	r20, r24
 280:	bd 01       	movw	r22, r26
 282:	48 51       	subi	r20, 0x18	; 24
 284:	5c 4f       	sbci	r21, 0xFC	; 252
 286:	6f 4f       	sbci	r22, 0xFF	; 255
 288:	7f 4f       	sbci	r23, 0xFF	; 255
 28a:	40 93 92 00 	sts	0x0092, r20	; 0x800092 <time_counter_board_led_blink>
 28e:	50 93 93 00 	sts	0x0093, r21	; 0x800093 <time_counter_board_led_blink+0x1>
 292:	60 93 94 00 	sts	0x0094, r22	; 0x800094 <time_counter_board_led_blink+0x2>
 296:	70 93 95 00 	sts	0x0095, r23	; 0x800095 <time_counter_board_led_blink+0x3>
			//board_led_status = !board_led_status;
			//if (board_led_status) PORTD |= 1 << pin_board_led;
			//else PORTD &= ~(1 << pin_board_led);
		}
		
		if (time_counter_buttons < time_ms)
 29a:	40 91 8e 00 	lds	r20, 0x008E	; 0x80008e <__data_end>
 29e:	50 91 8f 00 	lds	r21, 0x008F	; 0x80008f <__data_end+0x1>
 2a2:	60 91 90 00 	lds	r22, 0x0090	; 0x800090 <__data_end+0x2>
 2a6:	70 91 91 00 	lds	r23, 0x0091	; 0x800091 <__data_end+0x3>
 2aa:	48 17       	cp	r20, r24
 2ac:	59 07       	cpc	r21, r25
 2ae:	6a 07       	cpc	r22, r26
 2b0:	7b 07       	cpc	r23, r27
 2b2:	80 f6       	brcc	.-96     	; 0x254 <main+0x6>
		{
			time_counter_buttons = time_ms + 1;
 2b4:	01 96       	adiw	r24, 0x01	; 1
 2b6:	a1 1d       	adc	r26, r1
 2b8:	b1 1d       	adc	r27, r1
 2ba:	80 93 8e 00 	sts	0x008E, r24	; 0x80008e <__data_end>
 2be:	90 93 8f 00 	sts	0x008F, r25	; 0x80008f <__data_end+0x1>
 2c2:	a0 93 90 00 	sts	0x0090, r26	; 0x800090 <__data_end+0x2>
 2c6:	b0 93 91 00 	sts	0x0091, r27	; 0x800091 <__data_end+0x3>
			
			button_tick(&button_on_off);
 2ca:	8e e7       	ldi	r24, 0x7E	; 126
 2cc:	90 e0       	ldi	r25, 0x00	; 0
 2ce:	13 df       	rcall	.-474    	; 0xf6 <button_tick>
			button_tick(&button_reset);
 2d0:	8f e6       	ldi	r24, 0x6F	; 111
 2d2:	90 e0       	ldi	r25, 0x00	; 0
 2d4:	10 df       	rcall	.-480    	; 0xf6 <button_tick>
			button_tick(&button_red);
 2d6:	80 e6       	ldi	r24, 0x60	; 96
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	0d df       	rcall	.-486    	; 0xf6 <button_tick>
 2dc:	bb cf       	rjmp	.-138    	; 0x254 <main+0x6>

000002de <_exit>:
 2de:	f8 94       	cli

000002e0 <__stop_program>:
 2e0:	ff cf       	rjmp	.-2      	; 0x2e0 <__stop_program>
